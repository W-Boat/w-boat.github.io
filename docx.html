<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docx Forge - æœ¬åœ° DOCX åˆå¹¶ä¸åˆ†å‰²å·¥å…·</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <style>
        /* --- CSS å˜é‡å®šä¹‰ (æ”¯æŒä¸»é¢˜åˆ‡æ¢) --- */
        :root {
            --primary-color: #007aff;
            --primary-hover-color: #005ecb;
            --background-color: #f0f2f5;
            --card-bg-color: #ffffff;
            --text-color: #1f2937;
            --subtle-text-color: #6b7280;
            --border-color: #e5e7eb;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", "Arial", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
            --card-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
            --transition-speed: 0.2s;
        }

        /* --- åŸºç¡€æ ·å¼ --- */
        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 2rem 1rem;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container { max-width: 840px; margin: 0 auto; }
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2.5rem; flex-wrap: wrap; gap: 1rem;}
        .logo { font-size: 1.75rem; font-weight: 700; }
        .theme-switcher label { font-weight: 500; margin-right: 0.5rem; }
        .theme-switcher select { padding: 0.25rem 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; font-family: inherit; }
        
        .intro-section { text-align: center; background: var(--card-bg-color); padding: 3rem 2rem; border-radius: 12px; margin-bottom: 2.5rem; box-shadow: var(--card-shadow); }
        .intro-section h1 { font-size: 2.8rem; margin-bottom: 1rem; }
        .intro-section p { font-size: 1.1rem; color: var(--subtle-text-color); max-width: 600px; margin: 0 auto; }
        
        .tabs { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; }
        .tab-button { padding: 0.75rem 1.5rem; cursor: pointer; border: none; background-color: transparent; font-size: 1.1rem; font-weight: 600; color: var(--subtle-text-color); border-radius: 8px; position: relative; transition: all var(--transition-speed) ease; }
        .tab-button.active { color: var(--primary-color); background-color: rgba(0, 122, 255, 0.1); }
        .tab-content { display: none; }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .card { background-color: var(--card-bg-color); border-radius: 12px; box-shadow: var(--card-shadow); padding: 2rem; margin-bottom: 1.5rem; }
        .card-header { display: flex; align-items: center; gap: 0.75rem; font-size: 1.25rem; font-weight: 600; margin-bottom: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem; }
        .card-header .step-circle { width: 32px; height: 32px; border-radius: 50%; background-color: var(--primary-color); color: white; display: inline-flex; justify-content: center; align-items: center; font-size: 1rem; flex-shrink: 0;}
        
        .drop-zone { border: 2px dashed var(--border-color); border-radius: 8px; padding: 2rem; text-align: center; cursor: pointer; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        .drop-zone.drag-over { border-color: var(--primary-color); background-color: rgba(0, 122, 255, 0.05); }
        .drop-zone-content { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; pointer-events: none; }
        .drop-zone-icon { font-size: 2.5rem; color: var(--primary-color); }
        .drop-zone-text { font-weight: 500; }
        .drop-zone-subtext { font-size: 0.9rem; color: var(--subtle-text-color); }
        .file-input { display: none; }
        
        .file-list { min-height: 20px; }
        .file-list-item { display: flex; align-items: center; gap: 1rem; background-color: #f9fafb; border: 1px solid var(--border-color); padding: 0.75rem 1rem; border-radius: 8px; margin-bottom: 0.5rem; cursor: grab; transition: background-color var(--transition-speed), box-shadow var(--transition-speed); animation: slideInUp 0.3s ease; }
        .file-list-item.sortable-ghost { background: rgba(0, 122, 255, 0.1); }
        .file-list-item:active { cursor: grabbing; }
        .file-icon { color: var(--primary-color); }
        .file-name { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .delete-btn { background: none; border: none; color: var(--subtle-text-color); cursor: pointer; font-size: 1.2rem; transition: color var(--transition-speed); }
        .delete-btn:hover { color: var(--danger-color); }

        @keyframes slideInUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .action-button { width: 100%; padding: 0.8rem 1rem; font-size: 1.2rem; font-weight: 600; color: #fff; background-color: var(--primary-color); border: none; border-radius: 8px; cursor: pointer; display: flex; justify-content: center; align-items: center; gap: 0.5rem; transition: background-color var(--transition-speed), transform 0.1s; }
        .action-button:hover:not(:disabled) { background-color: var(--primary-hover-color); transform: translateY(-1px); }
        .action-button:disabled { background-color: #9ca3af; cursor: not-allowed; }
        .spinner { width: 18px; height: 18px; border: 2px solid rgba(255,255,255,0.5); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .split-info { background-color: #f8f9fa; border-radius: 8px; padding: 1rem; margin-top: 1.5rem; text-align: center;}
        .split-ranges input { width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; }
        .split-ranges p { font-size: 0.9em; color: var(--subtle-text-color); margin-bottom: 1rem; }

        .content-section { margin-top: 3rem; }
        .content-section h2 { text-align: center; margin-bottom: 1.5rem; font-size: 1.8rem; }
        .features-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; }
        .feature-item { background: var(--card-bg-color); padding: 1.5rem; border-radius: 8px; box-shadow: var(--card-shadow); text-align: center; }
        .feature-item h3 { margin-bottom: 0.5rem; }
        .feature-item .icon { font-size: 2.5rem; margin-bottom: 1rem; color: var(--primary-color); }
        
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: var(--text-color); color: white; padding: 10px 20px; border-radius: 6px; z-index: 1000; opacity: 0; transition: opacity 0.5s, bottom 0.5s; font-weight: 500;}
        .toast.show { opacity: 1; bottom: 30px; }
        .toast.error { background-color: var(--danger-color); }

        @media (max-width: 768px) {
            body { padding: 1rem 0.5rem; }
            .intro-section h1 { font-size: 2rem; }
            .card { padding: 1.5rem; }
        }
    </style>
</head>
<body>

    <div class="container">
        <header class="main-header">
            <div class="logo">ğŸ“„ Docx Forge</div>
            <div class="theme-switcher">
                <label for="theme-select">ä¸»é¢˜:</label>
                <select id="theme-select">
                    <option value="default">é»˜è®¤è“</option>
                    <option value="green">æ´»åŠ›ç»¿</option>
                    <option value="purple">ä¼˜é›…ç´«</option>
                </select>
            </div>
        </header>

        <section class="intro-section">
            <h1>æœ¬åœ° DOCX åˆå¹¶ä¸åˆ†å‰²å·¥å…·</h1>
            <p>è½»æ¾æ‹–æ‹½ã€æ’åºã€åˆå¹¶æˆ–åˆ†å‰²æ‚¨çš„ DOCX æ–‡ä»¶ã€‚æ‰€æœ‰æ“ä½œå‡åœ¨æ‚¨çš„æµè§ˆå™¨ä¸­å®Œæˆï¼Œç¡®ä¿æ‚¨çš„æ–‡ä»¶éšç§å’Œå®‰å…¨ã€‚</p>
        </section>

        <div class="tabs">
            <button class="tab-button active" data-tab="merge-tab">åˆå¹¶ DOCX</button>
            <button class="tab-button" data-tab="split-tab">åˆ†å‰² DOCX</button>
        </div>

        <!-- Merge Tab -->
        <div id="merge-tab" class="tab-content active">
            <div class="card">
                <div class="card-header"><span class="step-circle">1</span><span>ä¸Šä¼ å¹¶æ‹–æ‹½æ’åº</span></div>
                <label for="merge-file-input" id="merge-drop-zone" class="drop-zone">
                    <div class="drop-zone-content">
                        <div class="drop-zone-icon">ğŸš€</div>
                        <span class="drop-zone-text">ç‚¹å‡»é€‰æ‹© æˆ– æ‹–æ‹½å¤šä¸ª .docx æ–‡ä»¶</span>
                        <span class="drop-zone-subtext">æŒ‰ä½æ–‡ä»¶å¯æ‹–æ‹½æ’åº</span>
                    </div>
                </label>
                <input type="file" id="merge-file-input" class="file-input" multiple accept=".docx,.docm,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
                <div id="merge-file-list" class="file-list" style="margin-top: 1.5rem;"></div>
            </div>

            <button id="merge-button" class="action-button" disabled>
                <span id="merge-button-text">è¯·å…ˆä¸Šä¼ è‡³å°‘2ä¸ªæ–‡ä»¶</span>
            </button>
        </div>

        <!-- Split Tab -->
        <div id="split-tab" class="tab-content">
             <div class="card">
                <div class="card-header"><span class="step-circle">1</span><span>ä¸Šä¼ å•ä¸ªæ–‡ä»¶</span></div>
                 <label for="split-file-input" id="split-drop-zone" class="drop-zone">
                     <div class="drop-zone-content">
                         <div class="drop-zone-icon">âœ‚ï¸</div>
                         <span class="drop-zone-text">ç‚¹å‡»é€‰æ‹© æˆ– æ‹–æ‹½ä¸€ä¸ª .docx æ–‡ä»¶</span>
                     </div>
                </label>
                <input type="file" id="split-file-input" class="file-input" accept=".docx,.docm,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
                <div id="split-info" class="split-info" style="display: none;"></div>
            </div>
            <div class="card" id="split-options-card" style="display: none;">
                <div class="card-header"><span class="step-circle">2</span><span>è®¾ç½®åˆ†å‰²èŒƒå›´</span></div>
                <div class="split-ranges">
                    <p>æ ¹æ®æ®µè½æ•°è¿›è¡Œåˆ†å‰²ã€‚ä¾‹å¦‚ï¼š<code>1-50</code> (ç¬¬1åˆ°50æ®µ), <code>51-100</code>, <code>101-</code> (ç¬¬101æ®µåˆ°ç»“å°¾)ã€‚æ¯è¡Œä»£è¡¨ä¸€ä¸ªåˆ†å‰²åçš„æ–‡ä»¶ã€‚</p>
                    <textarea id="split-ranges-input" rows="4" class="split-ranges input" placeholder="1-10
11-20
21-"></textarea>
                </div>
            </div>
            <button id="split-button" class="action-button" disabled>
                <span id="split-button-text">è¯·å…ˆä¸Šä¼ æ–‡ä»¶</span>
            </button>
        </div>

        <!-- Features Section -->
        <section class="content-section">
            <h2>æ ¸å¿ƒç‰¹æ€§</h2>
            <div class="features-grid">
                <div class="feature-item">
                    <div class="icon">ğŸ”’</div>
                    <h3>ç»å¯¹éšç§</h3>
                    <p>æ‰€æœ‰æ–‡ä»¶å¤„ç†éƒ½åœ¨æ‚¨çš„æµè§ˆå™¨æœ¬åœ°è¿›è¡Œï¼Œæ‚¨çš„æ–‡æ¡£ä¸ä¼šè¢«ä¸Šä¼ åˆ°ä»»ä½•æœåŠ¡å™¨ã€‚</p>
                </div>
                <div class="feature-item">
                    <div class="icon">âœ¨</div>
                    <h3>æ™ºèƒ½åˆå¹¶</h3>
                    <p>å°½æœ€å¤§åŠªåŠ›åœ¨åˆå¹¶åä¿æŒåŸå§‹æ–‡æ¡£çš„æ–‡æœ¬æ ¼å¼ã€è¡¨æ ¼å’Œå›¾ç‰‡ç­‰å†…å®¹ã€‚</p>
                </div>
                <div class="feature-item">
                    <div class="icon">ğŸ“±</div>
                    <h3>å…¨å¹³å°å…¼å®¹</h3>
                    <p>å“åº”å¼è®¾è®¡ï¼Œæ— è®ºæ˜¯åœ¨æ¡Œé¢è¿˜æ˜¯æ‰‹æœºä¸Šï¼Œéƒ½èƒ½è·å¾—æµç•…çš„æ“ä½œä½“éªŒã€‚</p>
                </div>
            </div>
        </section>
    </div>
    
    <div id="toast" class="toast"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Globals and State ---
        const dom = {
            // Merge elements
            mergeDropZone: document.getElementById('merge-drop-zone'),
            mergeFileInput: document.getElementById('merge-file-input'),
            mergeFileList: document.getElementById('merge-file-list'),
            mergeButton: document.getElementById('merge-button'),
            mergeButtonText: document.getElementById('merge-button-text'),
            // Split elements
            splitDropZone: document.getElementById('split-drop-zone'),
            splitFileInput: document.getElementById('split-file-input'),
            splitInfo: document.getElementById('split-info'),
            splitOptionsCard: document.getElementById('split-options-card'),
            splitRangesInput: document.getElementById('split-ranges-input'),
            splitButton: document.getElementById('split-button'),
            splitButtonText: document.getElementById('split-button-text'),
            // Global
            themeSelect: document.getElementById('theme-select'),
            tabs: document.querySelectorAll('.tab-button'),
            tabContents: document.querySelectorAll('.tab-content'),
            toast: document.getElementById('toast'),
        };

        let mergeFiles = []; // Array to hold file data for merging
        let splitFile = null; // Object to hold the file for splitting
        let sortable; // Sortable.js instance

        // --- Utility Functions ---
        const showToast = (message, isError = false) => {
            dom.toast.textContent = message;
            dom.toast.className = `toast show ${isError ? 'error' : ''}`;
            setTimeout(() => {
                dom.toast.className = 'toast';
            }, 3000);
        };
        
        const showLoading = (button, textElement, message) => {
            button.disabled = true;
            textElement.innerHTML = `<div class="spinner"></div><span>${message}</span>`;
        };

        const hideLoading = (button, textElement, originalText) => {
            button.disabled = false;
            textElement.innerHTML = `<span>${originalText}</span>`;
        };

        const readFileAsArrayBuffer = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        };

        // --- UI Interaction Logic ---

        // Tab switching
        dom.tabs.forEach(button => {
            button.addEventListener('click', () => {
                dom.tabs.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                const tabId = button.dataset.tab;
                dom.tabContents.forEach(content => {
                    content.classList.toggle('active', content.id === tabId);
                });
            });
        });

        // Theme switcher
        dom.themeSelect.addEventListener('change', (e) => {
            const theme = e.target.value;
            const root = document.documentElement;
            const themes = {
                default: { primary: '#007aff', hover: '#005ecb' },
                green: { primary: '#10b981', hover: '#059669' },
                purple: { primary: '#8b5cf6', hover: '#7c3aed' }
            };
            root.style.setProperty('--primary-color', themes[theme].primary);
            root.style.setProperty('--primary-hover-color', themes[theme].hover);
        });

        // Generic drag-and-drop handler
        const setupDropZone = (dropZone, fileInput, fileHandler) => {
            dropZone.addEventListener('click', () => fileInput.click());
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                if (e.dataTransfer.files.length) {
                    fileInput.files = e.dataTransfer.files;
                    fileHandler(e.dataTransfer.files);
                }
            });
            fileInput.addEventListener('change', (e) => fileHandler(e.target.files));
        };

        // --- Merge Logic ---
        const handleMergeFiles = (files) => {
            const newFiles = Array.from(files).filter(file => file.name.endsWith('.docx') || file.name.endsWith('.docm'));
            if (newFiles.length === 0) return;
            mergeFiles.push(...newFiles);
            renderMergeList();
            updateMergeButtonState();
        };

        const renderMergeList = () => {
            dom.mergeFileList.innerHTML = '';
            mergeFiles.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'file-list-item';
                item.dataset.id = index;
                item.innerHTML = `
                    <span class="file-icon">ğŸ“„</span>
                    <span class="file-name">${file.name}</span>
                    <button class="delete-btn" data-index="${index}" title="åˆ é™¤">âœ–</button>
                `;
                dom.mergeFileList.appendChild(item);
            });

            // Add delete listeners
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(e.currentTarget.dataset.index, 10);
                    mergeFiles.splice(index, 1);
                    renderMergeList();
                    updateMergeButtonState();
                });
            });
        };
        
        const updateMergeButtonState = () => {
            if (mergeFiles.length >= 2) {
                dom.mergeButton.disabled = false;
                dom.mergeButtonText.textContent = `åˆå¹¶ ${mergeFiles.length} ä¸ªæ–‡ä»¶`;
            } else {
                dom.mergeButton.disabled = true;
                dom.mergeButtonText.textContent = 'è¯·å…ˆä¸Šä¼ è‡³å°‘2ä¸ªæ–‡ä»¶';
            }
        };

        if (dom.mergeFileList) {
            sortable = Sortable.create(dom.mergeFileList, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                onEnd: (evt) => {
                    // Reorder the mergeFiles array
                    const [movedItem] = mergeFiles.splice(evt.oldIndex, 1);
                    mergeFiles.splice(evt.newIndex, 0, movedItem);
                    renderMergeList(); // Re-render to update indices correctly
                },
            });
        }
        
        const onMerge = async () => {
            if (mergeFiles.length < 2) {
                showToast('è¯·é€‰æ‹©è‡³å°‘ä¸¤ä¸ªæ–‡ä»¶è¿›è¡Œåˆå¹¶', true);
                return;
            }

            showLoading(dom.mergeButton, dom.mergeButtonText, 'æ­£åœ¨å‡†å¤‡...');
            const orderedFiles = Array.from(dom.mergeFileList.children)
                .map(item => mergeFiles[parseInt(item.dataset.id, 10)]);

            try {
                const baseFile = await readFileAsArrayBuffer(orderedFiles[0]);
                const baseZip = await JSZip.loadAsync(baseFile);
                
                const parser = new DOMParser();
                const serializer = new XMLSerializer();

                let baseDocXmlStr = await baseZip.file("word/document.xml").async("string");
                let baseDocXml = parser.parseFromString(baseDocXmlStr, "text/xml");
                let baseBody = baseDocXml.querySelector("body");
                let baseLastSectPr = baseBody.querySelector(":scope > sectPr");

                let baseRelsXmlStr = await baseZip.file("word/_rels/document.xml.rels").async("string");
                let baseRelsXml = parser.parseFromString(baseRelsXmlStr, "text/xml");
                let baseRelationships = baseRelsXml.querySelector("Relationships");
                let maxId = Array.from(baseRelationships.children).reduce((max, r) => Math.max(max, parseInt(r.id.replace('rId', ''), 10)), 0);

                for (let i = 1; i < orderedFiles.length; i++) {
                    showLoading(dom.mergeButton, dom.mergeButtonText, `æ­£åœ¨åˆå¹¶æ–‡ä»¶ ${i + 1}/${orderedFiles.length}`);

                    // Add a page break before appending new content
                    const pageBreak = baseDocXml.createElement("w:p");
                    pageBreak.innerHTML = '<w:r><w:br w:type="page"/></w:r>';
                    baseBody.insertBefore(pageBreak, baseLastSectPr);

                    const nextFile = await readFileAsArrayBuffer(orderedFiles[i]);
                    const nextZip = await JSZip.loadAsync(nextFile);
                    
                    if (!nextZip.file("word/document.xml") || !nextZip.file("word/_rels/document.xml.rels")) continue;

                    const nextDocXmlStr = await nextZip.file("word/document.xml").async("string");
                    const nextDocXml = parser.parseFromString(nextDocXmlStr, "text/xml");
                    
                    const nextRelsXmlStr = await nextZip.file("word/_rels/document.xml.rels").async("string");
                    const nextRelsXml = parser.parseFromString(nextRelsXmlStr, "text/xml");
                    
                    const idMap = new Map();

                    // Process relationships (for images, etc.)
                    for (const rel of nextRelsXml.querySelectorAll("Relationship")) {
                        const oldId = rel.getAttribute("Id");
                        const newId = `rId${++maxId}`;
                        idMap.set(oldId, newId);
                        
                        rel.setAttribute("Id", newId);
                        const target = rel.getAttribute("Target");

                        if (target.startsWith("media/")) {
                            const mediaFile = nextZip.file(`word/${target}`);
                            if (mediaFile) {
                                const mediaData = await mediaFile.async("arraybuffer");
                                baseZip.file(`word/${target}`, mediaData);
                            }
                        }
                        baseRelationships.appendChild(rel);
                    }
                    
                    // Remap IDs in the document content
                    const blips = nextDocXml.querySelectorAll("a\\:blip, blip"); // a:blip for drawings, blip for older formats
                    for(const blip of blips) {
                        const embedId = blip.getAttribute("r:embed");
                        if(idMap.has(embedId)) {
                            blip.setAttribute("r:embed", idMap.get(embedId));
                        }
                    }

                    // Append content
                    const nextBody = nextDocXml.querySelector("body");
                    for (const child of Array.from(nextBody.children)) {
                        if (child.tagName !== 'w:sectPr') {
                            const importedNode = baseDocXml.importNode(child, true);
                            baseBody.insertBefore(importedNode, baseLastSectPr);
                        }
                    }
                }
                
                showLoading(dom.mergeButton, dom.mergeButtonText, 'æ­£åœ¨ç”Ÿæˆæ–‡ä»¶...');
                baseZip.file("word/document.xml", serializer.serializeToString(baseDocXml));
                baseZip.file("word/_rels/document.xml.rels", serializer.serializeToString(baseRelsXml));

                const blob = await baseZip.generateAsync({
                    type: "blob",
                    mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                });

                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "merged_document.docx";
                link.click();
                URL.revokeObjectURL(link.href);

                showToast('åˆå¹¶æˆåŠŸï¼');

            } catch (e) {
                console.error(e);
                showToast('åˆå¹¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æˆ–æŸ¥çœ‹æ§åˆ¶å°æ—¥å¿—', true);
            } finally {
                hideLoading(dom.mergeButton, dom.mergeButtonText, `åˆå¹¶ ${mergeFiles.length} ä¸ªæ–‡ä»¶`);
            }
        };


        // --- Split Logic ---
        const handleSplitFile = async (files) => {
            if (files.length === 0) return;
            splitFile = files[0];
            
            showLoading(dom.splitButton, dom.splitButtonText, 'æ­£åœ¨åˆ†æ...');
            dom.splitOptionsCard.style.display = 'none';
            dom.splitInfo.style.display = 'none';

            try {
                const buffer = await readFileAsArrayBuffer(splitFile);
                const zip = await JSZip.loadAsync(buffer);
                const docXmlStr = await zip.file("word/document.xml").async("string");
                const parser = new DOMParser();
                const docXml = parser.parseFromString(docXmlStr, "text/xml");
                const paragraphs = docXml.querySelectorAll("w\\:p, p");
                
                dom.splitInfo.innerHTML = `<strong>æ–‡ä»¶å:</strong> ${splitFile.name} | <strong>æ€»æ®µè½æ•°:</strong> ${paragraphs.length}`;
                dom.splitInfo.style.display = 'block';
                dom.splitOptionsCard.style.display = 'block';
                dom.splitButton.disabled = false;
                dom.splitButtonText.textContent = 'å¼€å§‹åˆ†å‰²';
            } catch (e) {
                console.error(e);
                showToast('æ–‡ä»¶åˆ†æå¤±è´¥ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„DOCXæ–‡ä»¶', true);
                 dom.splitButtonText.textContent = 'è¯·å…ˆä¸Šä¼ æ–‡ä»¶';
            } finally {
                hideLoading(dom.splitButton, dom.splitButtonText, 'å¼€å§‹åˆ†å‰²');
                if (splitFile) dom.splitButton.disabled = false;
            }
        };

        const onSplit = async () => {
            if (!splitFile) {
                showToast('è¯·å…ˆä¸Šä¼ ä¸€ä¸ªæ–‡ä»¶', true);
                return;
            }
            const rangesStr = dom.splitRangesInput.value.trim();
            if (!rangesStr) {
                showToast('è¯·è¾“å…¥åˆ†å‰²èŒƒå›´', true);
                return;
            }

            showLoading(dom.splitButton, dom.splitButtonText, 'æ­£åœ¨åˆ†å‰²...');
            
            try {
                const buffer = await readFileAsArrayBuffer(splitFile);
                const baseZip = await JSZip.loadAsync(buffer);
                const docXmlStr = await baseZip.file("word/document.xml").async("string");
                const relsXmlStr = await baseZip.file("word/_rels/document.xml.rels")?.async("string");

                const parser = new DOMParser();
                const serializer = new XMLSerializer();
                
                const baseDocXml = parser.parseFromString(docXmlStr, "text/xml");
                const allParagraphs = Array.from(baseDocXml.querySelectorAll("w\\:p, p"));
                const totalParagraphs = allParagraphs.length;
                const ranges = rangesStr.split('\n').map(line => line.trim()).filter(Boolean);
                
                let successCount = 0;
                for (let i = 0; i < ranges.length; i++) {
                     showLoading(dom.splitButton, dom.splitButtonText, `å¤„ç†éƒ¨åˆ† ${i+1}/${ranges.length}`);
                    const range = ranges[i];
                    let [start, end] = range.split('-').map(n => n.trim());
                    start = parseInt(start, 10);
                    end = end ? parseInt(end, 10) : totalParagraphs;

                    if (isNaN(start) || start < 1 || start > totalParagraphs) {
                        showToast(`èŒƒå›´ "${range}" çš„èµ·å§‹å€¼æ— æ•ˆ`, true);
                        continue;
                    }

                    const paragraphsToKeep = allParagraphs.slice(start - 1, end);
                    
                    const newZip = new JSZip();
                    const newDocXml = parser.parseFromString(docXmlStr.substring(0, docXmlStr.indexOf("<w:body>") + 8) + "</w:body></w:document>", "text/xml");
                    const newBody = newDocXml.querySelector("body");
                    const baseSectPr = baseDocXml.querySelector("body > sectPr");

                    const relsToKeep = new Map();

                    for (const p of paragraphsToKeep) {
                        const blips = p.querySelectorAll("a\\:blip, blip");
                        for(const blip of blips) {
                            const embedId = blip.getAttribute("r:embed");
                            if(embedId) relsToKeep.set(embedId, null);
                        }
                        newBody.appendChild(p.cloneNode(true));
                    }
                    if(baseSectPr) newBody.appendChild(baseSectPr.cloneNode(true));
                    
                    // Copy necessary files
                    for (const [filePath, file] of Object.entries(baseZip.files)) {
                        if (filePath === 'word/document.xml' || filePath === 'word/_rels/document.xml.rels') continue;
                        if (!filePath.endsWith('/')) {
                             newZip.file(filePath, await file.async('arraybuffer'));
                        } else {
                            newZip.folder(filePath);
                        }
                    }
                    
                    // Filter relationships
                    if (relsXmlStr) {
                         const baseRelsXml = parser.parseFromString(relsXmlStr, "text/xml");
                         const newRelsXml = parser.parseFromString(relsXmlStr.substring(0, relsXmlStr.indexOf("<Relationships>") + 15) + "</Relationships>", "text/xml");
                         const newRelationships = newRelsXml.querySelector("Relationships");

                        for (const rel of baseRelsXml.querySelectorAll("Relationship")) {
                            if (relsToKeep.has(rel.getAttribute("Id"))) {
                                newRelationships.appendChild(rel.cloneNode(true));
                            }
                        }
                         newZip.file("word/_rels/document.xml.rels", serializer.serializeToString(newRelsXml));
                    }

                    newZip.file("word/document.xml", serializer.serializeToString(newDocXml));

                    const blob = await newZip.generateAsync({ type: 'blob' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `split_${start}-${end}_${splitFile.name}`;
                    link.click();
                    URL.revokeObjectURL(link.href);
                    successCount++;
                }
                
                if (successCount > 0) {
                     showToast(`æˆåŠŸç”Ÿæˆ ${successCount} ä¸ªåˆ†å‰²æ–‡ä»¶ï¼`);
                }

            } catch(e) {
                console.error(e);
                showToast('åˆ†å‰²å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æˆ–æ§åˆ¶å°æ—¥å¿—', true);
            } finally {
                hideLoading(dom.splitButton, dom.splitButtonText, 'å¼€å§‹åˆ†å‰²');
            }

        };

        // --- Initial Setup ---
        setupDropZone(dom.mergeDropZone, dom.mergeFileInput, handleMergeFiles);
        setupDropZone(dom.splitDropZone, dom.splitFileInput, handleSplitFile);
        dom.mergeButton.addEventListener('click', onMerge);
        dom.splitButton.addEventListener('click', onSplit);

    });
    </script>
</body>
</html>