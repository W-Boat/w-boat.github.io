<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docx Forge - 本地 DOCX 合并与分割工具</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <style>
        /* --- CSS 变量定义 (支持主题切换) --- */
        :root {
            --primary-color: #007aff;
            --primary-hover-color: #005ecb;
            --background-color: #f0f2f5;
            --card-bg-color: #ffffff;
            --text-color: #1f2937;
            --subtle-text-color: #6b7280;
            --border-color: #e5e7eb;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", "Arial", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
            --card-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
            --transition-speed: 0.2s;
        }

        /* --- 基础样式 --- */
        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 2rem 1rem;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container { max-width: 840px; margin: 0 auto; }
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2.5rem; flex-wrap: wrap; gap: 1rem;}
        .logo { font-size: 1.75rem; font-weight: 700; }
        .theme-switcher label { font-weight: 500; margin-right: 0.5rem; }
        .theme-switcher select { padding: 0.25rem 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; font-family: inherit; }
        
        .intro-section { text-align: center; background: var(--card-bg-color); padding: 3rem 2rem; border-radius: 12px; margin-bottom: 2.5rem; box-shadow: var(--card-shadow); }
        .intro-section h1 { font-size: 2.8rem; margin-bottom: 1rem; }
        .intro-section p { font-size: 1.1rem; color: var(--subtle-text-color); max-width: 600px; margin: 0 auto; }
        
        .tabs { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; }
        .tab-button { padding: 0.75rem 1.5rem; cursor: pointer; border: none; background-color: transparent; font-size: 1.1rem; font-weight: 600; color: var(--subtle-text-color); border-radius: 8px; position: relative; transition: all var(--transition-speed) ease; }
        .tab-button.active { color: var(--primary-color); background-color: rgba(0, 122, 255, 0.1); }
        .tab-content { display: none; }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .card { background-color: var(--card-bg-color); border-radius: 12px; box-shadow: var(--card-shadow); padding: 2rem; margin-bottom: 1.5rem; }
        .card-header { display: flex; align-items: center; gap: 0.75rem; font-size: 1.25rem; font-weight: 600; margin-bottom: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem; }
        .card-header .step-circle { width: 32px; height: 32px; border-radius: 50%; background-color: var(--primary-color); color: white; display: inline-flex; justify-content: center; align-items: center; font-size: 1rem; flex-shrink: 0;}
        
        .drop-zone { border: 2px dashed var(--border-color); border-radius: 8px; padding: 2rem; text-align: center; cursor: pointer; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        .drop-zone.drag-over { border-color: var(--primary-color); background-color: rgba(0, 122, 255, 0.05); }
        .drop-zone-content { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; pointer-events: none; }
        .drop-zone-icon { font-size: 2.5rem; color: var(--primary-color); }
        .drop-zone-text { font-weight: 500; }
        .drop-zone-subtext { font-size: 0.9rem; color: var(--subtle-text-color); }
        .file-input { display: none; }
        
        .file-list { min-height: 20px; }
        .file-list-item { display: flex; align-items: center; gap: 1rem; background-color: #f9fafb; border: 1px solid var(--border-color); padding: 0.75rem 1rem; border-radius: 8px; margin-bottom: 0.5rem; cursor: grab; transition: background-color var(--transition-speed), box-shadow var(--transition-speed); animation: slideInUp 0.3s ease; }
        .file-list-item.sortable-ghost { background: rgba(0, 122, 255, 0.1); }
        .file-list-item:active { cursor: grabbing; }
        .file-icon { color: var(--primary-color); }
        .file-name { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .delete-btn { background: none; border: none; color: var(--subtle-text-color); cursor: pointer; font-size: 1.2rem; transition: color var(--transition-speed); }
        .delete-btn:hover { color: var(--danger-color); }

        @keyframes slideInUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .action-button { width: 100%; padding: 0.8rem 1rem; font-size: 1.2rem; font-weight: 600; color: #fff; background-color: var(--primary-color); border: none; border-radius: 8px; cursor: pointer; display: flex; justify-content: center; align-items: center; gap: 0.5rem; transition: background-color var(--transition-speed), transform 0.1s; }
        .action-button:hover:not(:disabled) { background-color: var(--primary-hover-color); transform: translateY(-1px); }
        .action-button:disabled { background-color: #9ca3af; cursor: not-allowed; }
        .spinner { width: 18px; height: 18px; border: 2px solid rgba(255,255,255,0.5); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .split-info { background-color: #f8f9fa; border-radius: 8px; padding: 1rem; margin-top: 1.5rem; text-align: center;}
        .split-ranges input { width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; }
        .split-ranges p { font-size: 0.9em; color: var(--subtle-text-color); margin-bottom: 1rem; }

        .content-section { margin-top: 3rem; }
        .content-section h2 { text-align: center; margin-bottom: 1.5rem; font-size: 1.8rem; }
        .features-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; }
        .feature-item { background: var(--card-bg-color); padding: 1.5rem; border-radius: 8px; box-shadow: var(--card-shadow); text-align: center; }
        .feature-item h3 { margin-bottom: 0.5rem; }
        .feature-item .icon { font-size: 2.5rem; margin-bottom: 1rem; color: var(--primary-color); }
        
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: var(--text-color); color: white; padding: 10px 20px; border-radius: 6px; z-index: 1000; opacity: 0; transition: opacity 0.5s, bottom 0.5s; font-weight: 500;}
        .toast.show { opacity: 1; bottom: 30px; }
        .toast.error { background-color: var(--danger-color); }

        @media (max-width: 768px) {
            body { padding: 1rem 0.5rem; }
            .intro-section h1 { font-size: 2rem; }
            .card { padding: 1.5rem; }
        }
    </style>
</head>
<body>

    <div class="container">
        <header class="main-header">
            <div class="logo">📄 Docx Forge</div>
            <div class="theme-switcher">
                <label for="theme-select">主题:</label>
                <select id="theme-select">
                    <option value="default">默认蓝</option>
                    <option value="green">活力绿</option>
                    <option value="purple">优雅紫</option>
                </select>
            </div>
        </header>

        <section class="intro-section">
            <h1>本地 DOCX 合并与分割工具</h1>
            <p>轻松拖拽、排序、合并或分割您的 DOCX 文件。所有操作均在您的浏览器中完成，确保您的文件隐私和安全。</p>
        </section>

        <div class="tabs">
            <button class="tab-button active" data-tab="merge-tab">合并 DOCX</button>
            <button class="tab-button" data-tab="split-tab">分割 DOCX</button>
        </div>

        <!-- Merge Tab -->
        <div id="merge-tab" class="tab-content active">
            <div class="card">
                <div class="card-header"><span class="step-circle">1</span><span>上传并拖拽排序</span></div>
                <label for="merge-file-input" id="merge-drop-zone" class="drop-zone">
                    <div class="drop-zone-content">
                        <div class="drop-zone-icon">🚀</div>
                        <span class="drop-zone-text">点击选择 或 拖拽多个 .docx 文件</span>
                        <span class="drop-zone-subtext">按住文件可拖拽排序</span>
                    </div>
                </label>
                <input type="file" id="merge-file-input" class="file-input" multiple accept=".docx,.docm,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
                <div id="merge-file-list" class="file-list" style="margin-top: 1.5rem;"></div>
            </div>

            <button id="merge-button" class="action-button" disabled>
                <span id="merge-button-text">请先上传至少2个文件</span>
            </button>
        </div>

        <!-- Split Tab -->
        <div id="split-tab" class="tab-content">
             <div class="card">
                <div class="card-header"><span class="step-circle">1</span><span>上传单个文件</span></div>
                 <label for="split-file-input" id="split-drop-zone" class="drop-zone">
                     <div class="drop-zone-content">
                         <div class="drop-zone-icon">✂️</div>
                         <span class="drop-zone-text">点击选择 或 拖拽一个 .docx 文件</span>
                     </div>
                </label>
                <input type="file" id="split-file-input" class="file-input" accept=".docx,.docm,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
                <div id="split-info" class="split-info" style="display: none;"></div>
            </div>
            <div class="card" id="split-options-card" style="display: none;">
                <div class="card-header"><span class="step-circle">2</span><span>设置分割范围</span></div>
                <div class="split-ranges">
                    <p>根据段落数进行分割。例如：<code>1-50</code> (第1到50段), <code>51-100</code>, <code>101-</code> (第101段到结尾)。每行代表一个分割后的文件。</p>
                    <textarea id="split-ranges-input" rows="4" class="split-ranges input" placeholder="1-10
11-20
21-"></textarea>
                </div>
            </div>
            <button id="split-button" class="action-button" disabled>
                <span id="split-button-text">请先上传文件</span>
            </button>
        </div>

        <!-- Features Section -->
        <section class="content-section">
            <h2>核心特性</h2>
            <div class="features-grid">
                <div class="feature-item">
                    <div class="icon">🔒</div>
                    <h3>绝对隐私</h3>
                    <p>所有文件处理都在您的浏览器本地进行，您的文档不会被上传到任何服务器。</p>
                </div>
                <div class="feature-item">
                    <div class="icon">✨</div>
                    <h3>智能合并</h3>
                    <p>尽最大努力在合并后保持原始文档的文本格式、表格和图片等内容。</p>
                </div>
                <div class="feature-item">
                    <div class="icon">📱</div>
                    <h3>全平台兼容</h3>
                    <p>响应式设计，无论是在桌面还是手机上，都能获得流畅的操作体验。</p>
                </div>
            </div>
        </section>
    </div>
    
    <div id="toast" class="toast"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Globals and State ---
        const dom = {
            // Merge elements
            mergeDropZone: document.getElementById('merge-drop-zone'),
            mergeFileInput: document.getElementById('merge-file-input'),
            mergeFileList: document.getElementById('merge-file-list'),
            mergeButton: document.getElementById('merge-button'),
            mergeButtonText: document.getElementById('merge-button-text'),
            // Split elements
            splitDropZone: document.getElementById('split-drop-zone'),
            splitFileInput: document.getElementById('split-file-input'),
            splitInfo: document.getElementById('split-info'),
            splitOptionsCard: document.getElementById('split-options-card'),
            splitRangesInput: document.getElementById('split-ranges-input'),
            splitButton: document.getElementById('split-button'),
            splitButtonText: document.getElementById('split-button-text'),
            // Global
            themeSelect: document.getElementById('theme-select'),
            tabs: document.querySelectorAll('.tab-button'),
            tabContents: document.querySelectorAll('.tab-content'),
            toast: document.getElementById('toast'),
        };

        let mergeFiles = []; // Array to hold file data for merging
        let splitFile = null; // Object to hold the file for splitting
        let sortable; // Sortable.js instance

        // --- Utility Functions ---
        const showToast = (message, isError = false) => {
            dom.toast.textContent = message;
            dom.toast.className = `toast show ${isError ? 'error' : ''}`;
            setTimeout(() => {
                dom.toast.className = 'toast';
            }, 3000);
        };
        
        const showLoading = (button, textElement, message) => {
            button.disabled = true;
            textElement.innerHTML = `<div class="spinner"></div><span>${message}</span>`;
        };

        const hideLoading = (button, textElement, originalText) => {
            button.disabled = false;
            textElement.innerHTML = `<span>${originalText}</span>`;
        };

        const readFileAsArrayBuffer = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        };

        // --- UI Interaction Logic ---

        // Tab switching
        dom.tabs.forEach(button => {
            button.addEventListener('click', () => {
                dom.tabs.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                const tabId = button.dataset.tab;
                dom.tabContents.forEach(content => {
                    content.classList.toggle('active', content.id === tabId);
                });
            });
        });

        // Theme switcher
        dom.themeSelect.addEventListener('change', (e) => {
            const theme = e.target.value;
            const root = document.documentElement;
            const themes = {
                default: { primary: '#007aff', hover: '#005ecb' },
                green: { primary: '#10b981', hover: '#059669' },
                purple: { primary: '#8b5cf6', hover: '#7c3aed' }
            };
            root.style.setProperty('--primary-color', themes[theme].primary);
            root.style.setProperty('--primary-hover-color', themes[theme].hover);
        });

        // Generic drag-and-drop handler
        const setupDropZone = (dropZone, fileInput, fileHandler) => {
            dropZone.addEventListener('click', () => fileInput.click());
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                if (e.dataTransfer.files.length) {
                    fileInput.files = e.dataTransfer.files;
                    fileHandler(e.dataTransfer.files);
                }
            });
            fileInput.addEventListener('change', (e) => fileHandler(e.target.files));
        };

        // --- Merge Logic ---
        const handleMergeFiles = (files) => {
            const newFiles = Array.from(files).filter(file => file.name.endsWith('.docx') || file.name.endsWith('.docm'));
            if (newFiles.length === 0) return;
            mergeFiles.push(...newFiles);
            renderMergeList();
            updateMergeButtonState();
        };

        const renderMergeList = () => {
            dom.mergeFileList.innerHTML = '';
            mergeFiles.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'file-list-item';
                item.dataset.id = index;
                item.innerHTML = `
                    <span class="file-icon">📄</span>
                    <span class="file-name">${file.name}</span>
                    <button class="delete-btn" data-index="${index}" title="删除">✖</button>
                `;
                dom.mergeFileList.appendChild(item);
            });

            // Add delete listeners
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(e.currentTarget.dataset.index, 10);
                    mergeFiles.splice(index, 1);
                    renderMergeList();
                    updateMergeButtonState();
                });
            });
        };
        
        const updateMergeButtonState = () => {
            if (mergeFiles.length >= 2) {
                dom.mergeButton.disabled = false;
                dom.mergeButtonText.textContent = `合并 ${mergeFiles.length} 个文件`;
            } else {
                dom.mergeButton.disabled = true;
                dom.mergeButtonText.textContent = '请先上传至少2个文件';
            }
        };

        if (dom.mergeFileList) {
            sortable = Sortable.create(dom.mergeFileList, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                onEnd: (evt) => {
                    // Reorder the mergeFiles array
                    const [movedItem] = mergeFiles.splice(evt.oldIndex, 1);
                    mergeFiles.splice(evt.newIndex, 0, movedItem);
                    renderMergeList(); // Re-render to update indices correctly
                },
            });
        }
        
        const onMerge = async () => {
            if (mergeFiles.length < 2) {
                showToast('请选择至少两个文件进行合并', true);
                return;
            }

            showLoading(dom.mergeButton, dom.mergeButtonText, '正在准备...');
            const orderedFiles = Array.from(dom.mergeFileList.children)
                .map(item => mergeFiles[parseInt(item.dataset.id, 10)]);

            try {
                const baseFile = await readFileAsArrayBuffer(orderedFiles[0]);
                const baseZip = await JSZip.loadAsync(baseFile);
                
                const parser = new DOMParser();
                const serializer = new XMLSerializer();

                let baseDocXmlStr = await baseZip.file("word/document.xml").async("string");
                let baseDocXml = parser.parseFromString(baseDocXmlStr, "text/xml");
                let baseBody = baseDocXml.querySelector("body");
                let baseLastSectPr = baseBody.querySelector(":scope > sectPr");

                let baseRelsXmlStr = await baseZip.file("word/_rels/document.xml.rels").async("string");
                let baseRelsXml = parser.parseFromString(baseRelsXmlStr, "text/xml");
                let baseRelationships = baseRelsXml.querySelector("Relationships");
                let maxId = Array.from(baseRelationships.children).reduce((max, r) => Math.max(max, parseInt(r.id.replace('rId', ''), 10)), 0);

                for (let i = 1; i < orderedFiles.length; i++) {
                    showLoading(dom.mergeButton, dom.mergeButtonText, `正在合并文件 ${i + 1}/${orderedFiles.length}`);

                    // Add a page break before appending new content
                    const pageBreak = baseDocXml.createElement("w:p");
                    pageBreak.innerHTML = '<w:r><w:br w:type="page"/></w:r>';
                    baseBody.insertBefore(pageBreak, baseLastSectPr);

                    const nextFile = await readFileAsArrayBuffer(orderedFiles[i]);
                    const nextZip = await JSZip.loadAsync(nextFile);
                    
                    if (!nextZip.file("word/document.xml") || !nextZip.file("word/_rels/document.xml.rels")) continue;

                    const nextDocXmlStr = await nextZip.file("word/document.xml").async("string");
                    const nextDocXml = parser.parseFromString(nextDocXmlStr, "text/xml");
                    
                    const nextRelsXmlStr = await nextZip.file("word/_rels/document.xml.rels").async("string");
                    const nextRelsXml = parser.parseFromString(nextRelsXmlStr, "text/xml");
                    
                    const idMap = new Map();

                    // Process relationships (for images, etc.)
                    for (const rel of nextRelsXml.querySelectorAll("Relationship")) {
                        const oldId = rel.getAttribute("Id");
                        const newId = `rId${++maxId}`;
                        idMap.set(oldId, newId);
                        
                        rel.setAttribute("Id", newId);
                        const target = rel.getAttribute("Target");

                        if (target.startsWith("media/")) {
                            const mediaFile = nextZip.file(`word/${target}`);
                            if (mediaFile) {
                                const mediaData = await mediaFile.async("arraybuffer");
                                baseZip.file(`word/${target}`, mediaData);
                            }
                        }
                        baseRelationships.appendChild(rel);
                    }
                    
                    // Remap IDs in the document content
                    const blips = nextDocXml.querySelectorAll("a\\:blip, blip"); // a:blip for drawings, blip for older formats
                    for(const blip of blips) {
                        const embedId = blip.getAttribute("r:embed");
                        if(idMap.has(embedId)) {
                            blip.setAttribute("r:embed", idMap.get(embedId));
                        }
                    }

                    // Append content
                    const nextBody = nextDocXml.querySelector("body");
                    for (const child of Array.from(nextBody.children)) {
                        if (child.tagName !== 'w:sectPr') {
                            const importedNode = baseDocXml.importNode(child, true);
                            baseBody.insertBefore(importedNode, baseLastSectPr);
                        }
                    }
                }
                
                showLoading(dom.mergeButton, dom.mergeButtonText, '正在生成文件...');
                baseZip.file("word/document.xml", serializer.serializeToString(baseDocXml));
                baseZip.file("word/_rels/document.xml.rels", serializer.serializeToString(baseRelsXml));

                const blob = await baseZip.generateAsync({
                    type: "blob",
                    mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                });

                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "merged_document.docx";
                link.click();
                URL.revokeObjectURL(link.href);

                showToast('合并成功！');

            } catch (e) {
                console.error(e);
                showToast('合并失败，请检查文件或查看控制台日志', true);
            } finally {
                hideLoading(dom.mergeButton, dom.mergeButtonText, `合并 ${mergeFiles.length} 个文件`);
            }
        };


        // --- Split Logic ---
        const handleSplitFile = async (files) => {
            if (files.length === 0) return;
            splitFile = files[0];
            
            showLoading(dom.splitButton, dom.splitButtonText, '正在分析...');
            dom.splitOptionsCard.style.display = 'none';
            dom.splitInfo.style.display = 'none';

            try {
                const buffer = await readFileAsArrayBuffer(splitFile);
                const zip = await JSZip.loadAsync(buffer);
                const docXmlStr = await zip.file("word/document.xml").async("string");
                const parser = new DOMParser();
                const docXml = parser.parseFromString(docXmlStr, "text/xml");
                const paragraphs = docXml.querySelectorAll("w\\:p, p");
                
                dom.splitInfo.innerHTML = `<strong>文件名:</strong> ${splitFile.name} | <strong>总段落数:</strong> ${paragraphs.length}`;
                dom.splitInfo.style.display = 'block';
                dom.splitOptionsCard.style.display = 'block';
                dom.splitButton.disabled = false;
                dom.splitButtonText.textContent = '开始分割';
            } catch (e) {
                console.error(e);
                showToast('文件分析失败，可能不是有效的DOCX文件', true);
                 dom.splitButtonText.textContent = '请先上传文件';
            } finally {
                hideLoading(dom.splitButton, dom.splitButtonText, '开始分割');
                if (splitFile) dom.splitButton.disabled = false;
            }
        };

        const onSplit = async () => {
            if (!splitFile) {
                showToast('请先上传一个文件', true);
                return;
            }
            const rangesStr = dom.splitRangesInput.value.trim();
            if (!rangesStr) {
                showToast('请输入分割范围', true);
                return;
            }

            showLoading(dom.splitButton, dom.splitButtonText, '正在分割...');
            
            try {
                const buffer = await readFileAsArrayBuffer(splitFile);
                const baseZip = await JSZip.loadAsync(buffer);
                const docXmlStr = await baseZip.file("word/document.xml").async("string");
                const relsXmlStr = await baseZip.file("word/_rels/document.xml.rels")?.async("string");

                const parser = new DOMParser();
                const serializer = new XMLSerializer();
                
                const baseDocXml = parser.parseFromString(docXmlStr, "text/xml");
                const allParagraphs = Array.from(baseDocXml.querySelectorAll("w\\:p, p"));
                const totalParagraphs = allParagraphs.length;
                const ranges = rangesStr.split('\n').map(line => line.trim()).filter(Boolean);
                
                let successCount = 0;
                for (let i = 0; i < ranges.length; i++) {
                     showLoading(dom.splitButton, dom.splitButtonText, `处理部分 ${i+1}/${ranges.length}`);
                    const range = ranges[i];
                    let [start, end] = range.split('-').map(n => n.trim());
                    start = parseInt(start, 10);
                    end = end ? parseInt(end, 10) : totalParagraphs;

                    if (isNaN(start) || start < 1 || start > totalParagraphs) {
                        showToast(`范围 "${range}" 的起始值无效`, true);
                        continue;
                    }

                    const paragraphsToKeep = allParagraphs.slice(start - 1, end);
                    
                    const newZip = new JSZip();
                    const newDocXml = parser.parseFromString(docXmlStr.substring(0, docXmlStr.indexOf("<w:body>") + 8) + "</w:body></w:document>", "text/xml");
                    const newBody = newDocXml.querySelector("body");
                    const baseSectPr = baseDocXml.querySelector("body > sectPr");

                    const relsToKeep = new Map();

                    for (const p of paragraphsToKeep) {
                        const blips = p.querySelectorAll("a\\:blip, blip");
                        for(const blip of blips) {
                            const embedId = blip.getAttribute("r:embed");
                            if(embedId) relsToKeep.set(embedId, null);
                        }
                        newBody.appendChild(p.cloneNode(true));
                    }
                    if(baseSectPr) newBody.appendChild(baseSectPr.cloneNode(true));
                    
                    // Copy necessary files
                    for (const [filePath, file] of Object.entries(baseZip.files)) {
                        if (filePath === 'word/document.xml' || filePath === 'word/_rels/document.xml.rels') continue;
                        if (!filePath.endsWith('/')) {
                             newZip.file(filePath, await file.async('arraybuffer'));
                        } else {
                            newZip.folder(filePath);
                        }
                    }
                    
                    // Filter relationships
                    if (relsXmlStr) {
                         const baseRelsXml = parser.parseFromString(relsXmlStr, "text/xml");
                         const newRelsXml = parser.parseFromString(relsXmlStr.substring(0, relsXmlStr.indexOf("<Relationships>") + 15) + "</Relationships>", "text/xml");
                         const newRelationships = newRelsXml.querySelector("Relationships");

                        for (const rel of baseRelsXml.querySelectorAll("Relationship")) {
                            if (relsToKeep.has(rel.getAttribute("Id"))) {
                                newRelationships.appendChild(rel.cloneNode(true));
                            }
                        }
                         newZip.file("word/_rels/document.xml.rels", serializer.serializeToString(newRelsXml));
                    }

                    newZip.file("word/document.xml", serializer.serializeToString(newDocXml));

                    const blob = await newZip.generateAsync({ type: 'blob' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `split_${start}-${end}_${splitFile.name}`;
                    link.click();
                    URL.revokeObjectURL(link.href);
                    successCount++;
                }
                
                if (successCount > 0) {
                     showToast(`成功生成 ${successCount} 个分割文件！`);
                }

            } catch(e) {
                console.error(e);
                showToast('分割失败，请检查文件或控制台日志', true);
            } finally {
                hideLoading(dom.splitButton, dom.splitButtonText, '开始分割');
            }

        };

        // --- Initial Setup ---
        setupDropZone(dom.mergeDropZone, dom.mergeFileInput, handleMergeFiles);
        setupDropZone(dom.splitDropZone, dom.splitFileInput, handleSplitFile);
        dom.mergeButton.addEventListener('click', onMerge);
        dom.splitButton.addEventListener('click', onSplit);

    });
    </script>
</body>
</html>